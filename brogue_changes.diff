diff --git a/.DS_Store b/.DS_Store
deleted file mode 100644
index 3f0d2ef..0000000
Binary files a/.DS_Store and /dev/null differ
diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
deleted file mode 100644
index 6a46cd7..0000000
--- a/.github/workflows/build.yml
+++ /dev/null
@@ -1,114 +0,0 @@
-name: "Build"
-on:
-  push:
-    # Only run on branches
-    branches:
-    - '**'
-
-jobs:
-
-  linux:
-    runs-on: ubuntu-20.04
-    steps:
-    - name: "Install dependencies"
-      run: |
-        sudo apt update -y
-        sudo apt install -y libsdl2-dev libsdl2-image-dev
-
-    - name: "Checkout sources"
-      uses: actions/checkout@v3
-
-    - name: "Compile"
-      run: |
-        make bin/brogue
-
-    - name: "Create artifact"
-      run: |
-        make BrogueCE-linux
-        tar -czvf BrogueCE-linux-x86_64.tar.gz BrogueCE-linux
-
-    - name: "Upload artifact"
-      uses: actions/upload-artifact@v3
-      with:
-        name: linux-x86_64
-        path: BrogueCE-linux-x86_64.tar.gz
-
-  macos:
-    runs-on: macos-12
-    steps:
-    - name: "Checkout sources"
-      uses: actions/checkout@v3
-
-    - name: "Prepare"
-      run: |
-        make macos/sdl2.rb
-
-    - name: "Cache SDL2"
-      uses: actions/cache@v3
-      with:
-        path: sdl2-cellar
-        key: sdl2-${{hashFiles('macos/sdl2.rb')}}
-
-    - name: "Compile and install dependencies"
-      run: |
-        if [ -d sdl2-cellar ]; then
-          cp -r sdl2-cellar $(brew --cellar)/sdl2
-          brew link sdl2
-        else
-          brew install --build-from-source ./macos/sdl2.rb
-          cp -r $(brew --cellar)/sdl2 sdl2-cellar
-        fi
-        brew install sdl2_image dylibbundler
-
-    - name: "Compile"
-      run: |
-        make MAC_APP=YES Brogue.app
-      env:
-        MACOSX_DEPLOYMENT_TARGET: "10.7"
-
-    - name: "Fix and bundle dylib references"
-      run: |
-        cd Brogue.app/Contents && dylibbundler -cd -b -x MacOS/brogue
-
-    - name: "Create artifact"
-      run: |
-        make BrogueCE-macos
-        zip -rll BrogueCE-macos-x86_64.zip BrogueCE-macos
-
-    - name: "Upload artifact"
-      uses: actions/upload-artifact@v3
-      with:
-        name: macos-x86_64
-        path: BrogueCE-macos-x86_64.zip
-
-  windows:
-    runs-on: windows-latest
-    steps:
-    - name: "Checkout sources"
-      uses: actions/checkout@v3
-
-    - name: "Install dependencies"
-      run: |
-        .\.github\get-deps-mingw.ps1
-
-    - name: "Compile"
-      shell: powershell
-      run: |
-        $env:path = $env:path + ";" + (Join-Path $pwd.Drive.Root "opt/local/x86_64-w64-mingw32/bin")
-        $env:path = $env:path + ';C:\Program Files (x86)\Windows Kits\10\bin\10.0.22000.0\x64'
-        mingw32-make SYSTEM=WINDOWS CC=gcc bin/brogue.exe
-
-    - name: "Create artifact"
-      run: |
-        mingw32-make SYSTEM=WINDOWS BrogueCE-windows
-        cp SDL2\x86_64-w64-mingw32\bin\SDL2.dll BrogueCE-windows
-        cp SDL2_image\x86_64-w64-mingw32\bin\zlib1.dll BrogueCE-windows
-        cp SDL2_image\x86_64-w64-mingw32\bin\SDL2_image.dll BrogueCE-windows
-        cp SDL2_image\x86_64-w64-mingw32\bin\libpng16-16.dll BrogueCE-windows
-        7z a BrogueCE-windows-x86_64.zip BrogueCE-windows
-
-    - name: "Upload artifact"
-      uses: actions/upload-artifact@v3
-      with:
-        name: windows-x86_64
-        path: BrogueCE-windows-x86_64.zip
diff --git a/README.md b/README.md
index a4a2ff8..418d5bc 100644
--- a/README.md
+++ b/README.md
@@ -1 +1 @@
-# K8s Dungeon Crawl
\ No newline at end of file
+# K8s Dungeon Crawl
diff --git a/brogue-game/.DS_Store b/brogue-game/.DS_Store
deleted file mode 100644
index 5008ddf..0000000
Binary files a/brogue-game/.DS_Store and /dev/null differ
diff --git a/brogue-game/Dockerfile b/brogue-game/Dockerfile
new file mode 100644
index 0000000..1bea2c8
--- /dev/null
+++ b/brogue-game/Dockerfile
@@ -0,0 +1,91 @@
+FROM ubuntu:22.04
+
+# Avoid prompts from apt-get asking for input during build
+ARG DEBIAN_FRONTEND=noninteractive
+
+# Install C build tools, VNC server, and xfce
+RUN apt-get update && apt-get install -y \
+    build-essential \
+    libjansson-dev \
+    libmicrohttpd-dev \
+    libncurses5-dev \
+    libsdl2-dev \
+    libsdl2-image-dev \
+    libpng-dev \
+    libjpeg-dev \
+    libtiff-dev \
+    libwebp-dev \
+    xfce4 \
+    xfce4-goodies \
+    x11vnc \
+    xvfb \
+    curl \
+    net-tools \
+    x11-xserver-utils \
+    libcurl4-openssl-dev \
+    && rm -rf /var/lib/apt/lists/*
+
+# Install Node.js
+RUN curl -fsSL https://deb.nodesource.com/setup_18.x | bash - \
+    && apt-get install -y nodejs
+
+RUN apt-get remove -y xfce4-power-manager && \
+    apt-get autoremove -y && \
+    rm -rf /var/lib/apt/lists/*
+
+# Download kubectl
+RUN curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" \
+    && chmod +x ./kubectl \
+    && mv ./kubectl /usr/local/bin/kubectl
+
+# Install noVNC and websockify
+RUN apt update && apt install -y git python3 python3-pip && \
+    pip3 install websockify && \
+    git clone https://github.com/novnc/noVNC.git /opt/noVNC
+
+# Link the noVNC HTML files to a convenient path
+RUN ln -s /opt/noVNC/vnc_lite.html /opt/noVNC/index.html
+
+# Set the working directory
+WORKDIR /app
+
+# Copy your Node.js and C application files
+COPY . /app
+
+# Create a desktop entry for the autostart
+RUN mkdir -p /root/.config/autostart && \
+    echo '[Desktop Entry]\nType=Application\nName=StartBrogue\nExec=/app/brogue -G\nX-GNOME-Autostart-enabled=true' > /root/.config/autostart/startbrogue.desktop
+
+# Disable xfwm4 compositing
+RUN mkdir -p /root/.config/xfce4/xfconf/xfce-perchannel-xml && \
+    echo '<?xml version="1.0" encoding="UTF-8"?><channel name="xfwm4" version="1.0"><property name="general" type="empty"><property name="use_compositing" type="bool" value="false"/></property></channel>' > /root/.config/xfce4/xfconf/xfce-perchannel-xml/xfwm4.xml
+
+# Build Brogue application and metrics server
+RUN make
+
+# Confirm that metrics_server was created and move it to /app if needed
+#RUN if [ -f "bin/metrics_server" ]; then cp bin/metrics_server /app/metrics_server; fi
+
+# Set up VNC
+ARG VNC_PASSWORD=password
+RUN mkdir ~/.vnc \
+    && x11vnc -storepasswd $VNC_PASSWORD ~/.vnc/passwd
+
+# Expose the VNC, noVNC, and metrics HTTP ports
+EXPOSE 15900 16080 18000
+
+# Set environment variables to center the Brogue window
+ENV SDL_VIDEO_WINDOW_POS=center
+ENV SDL_VIDEO_CENTERED=1
+ENV SDL_VIDEO_FULLSCREEN_DISPLAY=1
+
+# Set up the X virtual framebuffer (Xvfb) in the background, start XFCE, x11vnc, Brogue, noVNC, and the metrics server
+CMD bash -c "Xvfb :1 -screen 0 1280x960x24 & \
+             while ! xset -display :1 q; do sleep 1; done; \
+             DISPLAY=:1 xfce4-session & \
+             export SDL_VIDEODRIVER=dummy; \
+             DISPLAY=:1 xset r on & \
+             DISPLAY=:1 x11vnc -display :1 -usepw -forever -o /var/log/x11vnc.log & \
+             /opt/noVNC/utils/novnc_proxy --vnc localhost:5900 --listen 16080 & \
+             DISPLAY=:1 /app/brogue -G & \
+             wait"
\ No newline at end of file
diff --git a/brogue-game/Makefile b/brogue-game/Makefile
index 59e786f..d94d90f 100644
--- a/brogue-game/Makefile
+++ b/brogue-game/Makefile
@@ -2,8 +2,10 @@ include config.mk
 
 cflags := -Isrc/brogue -Isrc/platform -Isrc/variants -std=c99 \
 	-Wall -Wpedantic -Werror=implicit -Wno-parentheses -Wno-unused-result \
-	-Wformat -Werror=format-security -Wformat-overflow=0 -Wmissing-prototypes
-libs := -lm
+	-Wformat -Werror=format-security -Wformat-overflow=0 -Wmissing-prototypes \
+	-I$(shell brew --prefix curl)/include 
+libs := -lm -lmicrohttpd -L$(shell brew --prefix curl)/lib -lcurl 
+
 cppflags := -DDATADIR=$(DATADIR)
 
 sources := $(wildcard src/brogue/*.c) $(wildcard src/variants/*.c) $(addprefix src/platform/,main.c platformdependent.c null-platform.c)
@@ -86,4 +88,4 @@ vars/%: vars FORCE
 	@if cmp --quiet vars/$*.tmp vars/$*; then :; else cp vars/$*.tmp vars/$*; fi
 
 
-FORCE:
+FORCE:
\ No newline at end of file
diff --git a/brogue-game/bin/brogue b/brogue-game/bin/brogue
new file mode 100755
index 0000000..2c2c6f8
Binary files /dev/null and b/brogue-game/bin/brogue differ
diff --git a/brogue-game/config.mk b/brogue-game/config.mk
index 6f14b53..64d2799 100644
--- a/brogue-game/config.mk
+++ b/brogue-game/config.mk
@@ -9,6 +9,7 @@ TERMINAL := NO
 
 # Include graphical support. Requires SDL2 and SDL2_image
 GRAPHICS := YES
+
 # Path to sdl2-config script
 SDL_CONFIG := sdl2-config
 
diff --git a/brogue-game/k8s/brogue-clusterrolebindings.yaml b/brogue-game/k8s/brogue-clusterrolebindings.yaml
new file mode 100644
index 0000000..c27651c
--- /dev/null
+++ b/brogue-game/k8s/brogue-clusterrolebindings.yaml
@@ -0,0 +1,25 @@
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRoleBinding
+metadata:
+  name: dungeon-crawl-rbac
+subjects:
+- kind: ServiceAccount
+  name: brogue-sa
+  namespace: monsties
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: ClusterRole
+  name: namespace-manager 
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRoleBinding
+metadata:
+  name: deployment-manager-binding
+subjects:
+- kind: ServiceAccount
+  name: brogue-sa
+  namespace: monsties
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: ClusterRole
+  name: deployment-manager
diff --git a/brogue-game/k8s/brogue-clusterroles.yaml b/brogue-game/k8s/brogue-clusterroles.yaml
new file mode 100644
index 0000000..645cf36
--- /dev/null
+++ b/brogue-game/k8s/brogue-clusterroles.yaml
@@ -0,0 +1,17 @@
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRole
+metadata:
+  name: namespace-manager
+rules:
+- apiGroups: [""]
+  resources: ["namespaces"]
+  verbs: ["create", "get", "list", "watch", "delete", "update"]
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRole
+metadata:
+  name: deployment-manager
+rules:
+- apiGroups: ["apps"]
+  resources: ["deployments"]
+  verbs: ["create", "get", "list", "watch", "delete", "update"]
diff --git a/brogue-game/k8s/brogue-deployment.yaml b/brogue-game/k8s/brogue-deployment.yaml
new file mode 100644
index 0000000..782f6bd
--- /dev/null
+++ b/brogue-game/k8s/brogue-deployment.yaml
@@ -0,0 +1,40 @@
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: brogue
+  namespace: monsties
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: brogue
+  template:
+    metadata:
+      labels:
+        app: brogue
+    spec:
+      serviceAccountName: brogue-sa
+      containers:
+      - name: brogue
+        image: broguek8s:latest
+        imagePullPolicy: IfNotPresent
+        resources:
+          limits:
+            memory: "512Mi"
+            cpu: "1000m"
+          requests:
+            memory: "256Mi"
+            cpu: "500m"
+        securityContext:
+          privileged: true
+        ports:
+        - containerPort: 16080 # noVNC port
+        - containerPort: 15900 # VNC port
+        - containerPort: 18000 # Metrics port
+        env:
+        - name: DISPLAY
+          value: ":1"
+        - name: SDL_VIDEODRIVER
+          value: "x11"
+        - name: SDL_AUDIODRIVER
+          value: "dummy"
diff --git a/brogue-game/k8s/brogue-namespace.yaml b/brogue-game/k8s/brogue-namespace.yaml
new file mode 100644
index 0000000..a394b23
--- /dev/null
+++ b/brogue-game/k8s/brogue-namespace.yaml
@@ -0,0 +1,4 @@
+apiVersion: v1
+kind: Namespace
+metadata:
+  name: monsties
diff --git a/brogue-game/k8s/brogue-service.yaml b/brogue-game/k8s/brogue-service.yaml
new file mode 100644
index 0000000..985b577
--- /dev/null
+++ b/brogue-game/k8s/brogue-service.yaml
@@ -0,0 +1,19 @@
+apiVersion: v1
+kind: Service
+metadata:
+  name: brogue-service
+  namespace: monsties
+spec:
+  selector:
+    app: brogue
+  type: ClusterIP  # Change to NodePort or LoadBalancer if external access is required
+  ports:
+  - name: novnc
+    port: 16080
+    targetPort: 16080
+  - name: vnc
+    port: 15900
+    targetPort: 15900
+  - name: metrics
+    port: 18000
+    targetPort: 18000
\ No newline at end of file
diff --git a/brogue-game/k8s/brogue-serviceaccount.yaml b/brogue-game/k8s/brogue-serviceaccount.yaml
new file mode 100644
index 0000000..8c42297
--- /dev/null
+++ b/brogue-game/k8s/brogue-serviceaccount.yaml
@@ -0,0 +1,5 @@
+apiVersion: v1
+kind: ServiceAccount
+metadata:
+  name: brogue-sa
+  namespace: monsties
diff --git a/brogue-game/run.sh b/brogue-game/run.sh
new file mode 100755
index 0000000..be89b92
--- /dev/null
+++ b/brogue-game/run.sh
@@ -0,0 +1,168 @@
+#!/bin/bash
+
+# Set directory variables
+SCRIPT_DIR=$(dirname "$0")/k8s
+IMAGE_NAME="broguek8s:latest"
+CLUSTER_NAME="k3d-k3s-default"
+NAMESPACE_FILE="$SCRIPT_DIR/brogue-namespace.yaml"
+DEPLOYMENT_FILES=("$SCRIPT_DIR/brogue-deployment.yaml" "$SCRIPT_DIR/brogue-service.yaml" "$SCRIPT_DIR/brogue-clusterroles.yaml" "$SCRIPT_DIR/brogue-clusterrolebindings.yaml" "$SCRIPT_DIR/brogue-serviceaccount.yaml")
+LOCAL_PORT_16080=8090
+LOCAL_PORT_15900=5910
+LOCAL_PORT_18000=8010  # Add the metrics server port
+
+# Function to check if a port is in use
+check_port() {
+    local port=$1
+    if lsof -i ":$port" &>/dev/null; then
+        return 1  # Port is in use
+    else
+        return 0  # Port is available
+    fi
+}
+
+# Function to find the next available port starting from the given port
+find_available_port() {
+    local port=$1
+    while check_port $port; do
+        ((port++))
+    done
+    echo $port
+}
+
+# Check if "yolo" argument is provided
+if [[ " $@ " =~ " yolo " ]]; then
+    echo "YOLO mode: Automatically finding available ports for $LOCAL_PORT_16080, $LOCAL_PORT_15900, and $LOCAL_PORT_18000 if in use."
+    
+    # Find available port for noVNC
+    LOCAL_PORT_16080=$(find_available_port $LOCAL_PORT_16080)
+    echo "Selected noVNC port: $LOCAL_PORT_16080"
+
+    # Find available port for VNC
+    LOCAL_PORT_15900=$(find_available_port $LOCAL_PORT_15900)
+    echo "Selected VNC port: $LOCAL_PORT_15900"
+
+    # Find available port for Metrics
+    LOCAL_PORT_18000=$(find_available_port $LOCAL_PORT_18000)
+    echo "Selected Metrics port: $LOCAL_PORT_18000"
+else
+    # Check each port individually and prompt for action if any are in use
+    if ! check_port $LOCAL_PORT_16080; then
+        echo "Port $LOCAL_PORT_16080 is already in use."
+        echo "To free up this port, you can identify the process using it with:"
+        echo "   lsof -i :$LOCAL_PORT_16080"
+        echo "Then, terminate the process by running:"
+        echo "   kill -9 <PID>"
+        echo "Or, alternatively, change the LOCAL_PORT_16080 variable in this script to an available port."
+        exit 1
+    fi
+
+    if ! check_port $LOCAL_PORT_15900; then
+        echo "Port $LOCAL_PORT_15900 is already in use."
+        echo "To free up this port, you can identify the process using it with:"
+        echo "   lsof -i :$LOCAL_PORT_15900"
+        echo "Then, terminate the process by running:"
+        echo "   kill -9 <PID>"
+        echo "Or, alternatively, change the LOCAL_PORT_15900 variable in this script to an available port."
+        exit 1
+    fi
+
+    if ! check_port $LOCAL_PORT_18000; then
+        echo "Port $LOCAL_PORT_18000 is already in use."
+        echo "To free up this port, you can identify the process using it with:"
+        echo "   lsof -i :$LOCAL_PORT_18000"
+        echo "Then, terminate the process by running:"
+        echo "   kill -9 <PID>"
+        echo "Or, alternatively, change the LOCAL_PORT_18000 variable in this script to an available port."
+        exit 1
+    fi
+fi
+
+# Proceed with the rest of the script if ports are available or have been reassigned in YOLO mode
+echo "Ports $LOCAL_PORT_16080, $LOCAL_PORT_15900, and $LOCAL_PORT_18000 are available. Continuing with deployment..."
+
+# Step 1: Check if "build" argument is included, and build the Docker image if so
+if [[ " $@ " =~ " build " ]]; then
+    echo "Building Docker image $IMAGE_NAME..."
+    docker build -t $IMAGE_NAME .
+else
+    echo "Skipping Docker image build."
+fi
+
+# Step 2: Start the k3d cluster if it's not already running
+echo "Checking if k3d cluster $CLUSTER_NAME is running..."
+if ! k3d cluster list | grep -q "^$CLUSTER_NAME"; then
+    echo "Cluster $CLUSTER_NAME is not running. Starting cluster..."
+    k3d cluster create $CLUSTER_NAME --port "$LOCAL_PORT_16080:30080@loadbalancer" --port "$LOCAL_PORT_15900:30090@loadbalancer" --port "$LOCAL_PORT_18000:30800@loadbalancer"
+else
+    echo "Cluster $CLUSTER_NAME is already running."
+fi
+
+# Step 3: Import the Docker image into the k3d cluster
+echo "Importing Docker image into k3d cluster..."
+k3d image import $IMAGE_NAME -c $CLUSTER_NAME
+
+# Step 4: Delete the existing resources in the cluster
+echo "Deleting existing Kubernetes resources..."
+for file in "${DEPLOYMENT_FILES[@]}"; do
+    kubectl delete -f "$file" --ignore-not-found
+done
+kubectl delete -f "$NAMESPACE_FILE" --ignore-not-found
+
+# Step 5: Apply the namespace YAML file
+echo "Applying namespace file $NAMESPACE_FILE..."
+kubectl apply -f "$NAMESPACE_FILE"
+
+# Wait for the namespace to be ready
+NAMESPACE=$(awk '/name:/{print $2}' "$NAMESPACE_FILE")
+echo "Waiting for namespace $NAMESPACE to be ready..."
+until kubectl get namespace $NAMESPACE >/dev/null 2>&1; do
+    echo "Waiting for namespace $NAMESPACE..."
+    sleep 1
+done
+echo "Namespace $NAMESPACE is ready."
+
+# Step 6: Apply the other YAML files
+echo "Applying other Kubernetes resources..."
+for file in "${DEPLOYMENT_FILES[@]}"; do
+    kubectl apply -f "$file"
+done
+
+# Step 7: Wait for the Brogue pod to be created
+echo "Waiting for pod to be created..."
+until kubectl get pods -n $NAMESPACE -l app=brogue -o jsonpath="{.items[0].metadata.name}" 2>/dev/null; do
+    echo "Waiting for pod to be created..."
+    sleep 2
+done
+
+# Get the pod name
+POD_NAME=$(kubectl get pods -n $NAMESPACE -l app=brogue -o jsonpath="{.items[0].metadata.name}")
+echo "Pod $POD_NAME created. Waiting for it to be ready..."
+
+# Wait for the Brogue pod to be ready
+until [[ $(kubectl get pod $POD_NAME -n $NAMESPACE -o jsonpath='{.status.containerStatuses[0].ready}') == "true" ]]; do
+    echo "Waiting for pod $POD_NAME to be ready..."
+    sleep 2
+done
+echo "Pod $POD_NAME is ready."
+
+# Step 8: Start port forwarding in a new tmux session
+# Wait for the service to be ready
+echo "Waiting for brogue-service to be available..."
+until kubectl get svc -n $NAMESPACE brogue-service >/dev/null 2>&1; do
+    echo "Waiting for brogue-service to be available..."
+    sleep 2
+done
+echo "brogue-service is available. Starting port forwarding..."
+
+echo "Starting port forwarding in a tmux session..."
+tmux new-session -d -s brogue_port_forward "kubectl port-forward service/brogue-service -n $NAMESPACE $LOCAL_PORT_16080:16080 $LOCAL_PORT_15900:15900 $LOCAL_PORT_18000:18000 > port-forward.log 2>&1 || echo 'Port-forwarding failed' > tmux-error.log"
+
+# Inform the user about tmux session
+echo "Port forwarding started in a tmux session named 'brogue_port_forward'."
+echo "You can attach to the session with: tmux attach -t brogue_port_forward"
+echo "Or kill the session with: tmux kill-session -t brogue_port_forward"
+echo
+echo "Deployment complete. You can connect to Brogue using the following options:"
+echo " - For noVNC, open your browser and go to: http://localhost:$LOCAL_PORT_16080"
+echo " - For VNC, connect using a VNC client to: localhost:$LOCAL_PORT_15900"
+echo " - For metrics, connect to: http://localhost:$LOCAL_PORT_18000/metrics"
\ No newline at end of file
diff --git a/brogue-game/src/brogue/IO.c b/brogue-game/src/brogue/IO.c
index 53ad187..53f97f7 100644
--- a/brogue-game/src/brogue/IO.c
+++ b/brogue-game/src/brogue/IO.c
@@ -568,7 +568,6 @@ void mainInputLoop() {
     rogue.cursorLoc = INVALID_POS;
 
     while (!rogue.gameHasEnded && (!playingBack || !canceled)) { // repeats until the game ends
-
         oldRNG = rogue.RNG;
         rogue.RNG = RNG_COSMETIC;
 
@@ -4577,7 +4576,9 @@ short printMonsterInfo(creature *monst, short y, boolean dim, boolean highlight)
             }
         }
 
-        sprintf(buf, ": %s", monstName);
+        // K8S: To display portal name for the monster
+        //sprintf(buf, ": %s", monstName);
+        sprintf(buf, " %s", monst->portalName);
         printString(buf, monst->carriedItem?2:1, y++, (dim ? &gray : &white), &black, 0);
     }
 
diff --git a/brogue-game/src/brogue/MainMenu.c b/brogue-game/src/brogue/MainMenu.c
index bac1b0e..85f728f 100644
--- a/brogue-game/src/brogue/MainMenu.c
+++ b/brogue-game/src/brogue/MainMenu.c
@@ -26,6 +26,26 @@
 #include "Globals.h"
 #include <time.h>
 #include <limits.h>
+#include <curl/curl.h>
+#include <pthread.h>   // For threading
+#include <unistd.h>    // For sleep
+#include <stdio.h>
+// K8S: Include the portal header files
+#include "portal-player.h"
+#include "portal-monster.h"
+
+#include <time.h>    // For nanosleep if usleep is not available
+#ifndef _POSIX_C_SOURCE
+#define _POSIX_C_SOURCE 199309L  // Enables nanosleep support in strict C
+#endif
+
+void sleep_for_microseconds(int microseconds) {
+    struct timespec ts;
+    ts.tv_sec = microseconds / 100000;
+    ts.tv_nsec = (microseconds % 100000) * 1000;
+    nanosleep(&ts, NULL);
+}
+
 
 #define MENU_FLAME_PRECISION_FACTOR     10
 #define MENU_FLAME_RISE_SPEED           50
@@ -38,6 +58,48 @@
 
 #define MENU_FLAME_DENOMINATOR          (100 + MENU_FLAME_RISE_SPEED + MENU_FLAME_SPREAD_SPEED)
 
+// K8S: Define a flag to track if the thread has been started
+static int metrics_thread_started = 0;
+// K8S: Mutex to protect the flag
+static pthread_mutex_t metrics_thread_mutex = PTHREAD_MUTEX_INITIALIZER;
+// K8S: Function that calls update_metrics every 0.10 seconds
+void *metrics_update_loop(void *arg);
+void *metrics_update_loop(void *arg) {
+    while (1) {
+        update_metrics();
+        update_monster_metrics();
+        sleep_for_microseconds(10); // Sleep for 0.10 seconds
+    }
+    return NULL;
+}
+
+// K8S: Function to start the metrics thread if it has not been started
+void start_metrics_thread_if_needed() {
+    // K8S: Debug log
+    printf("Entering start_metrics_thread_if_needed\n");
+    // Lock the mutex to protect the metrics_thread_started flag
+    pthread_mutex_lock(&metrics_thread_mutex);
+    
+    // Check if the thread has already been started
+    if (!metrics_thread_started) {
+        pthread_t metrics_thread;
+        
+        // Create the thread and set the started flag if successful
+        if (pthread_create(&metrics_thread, NULL, metrics_update_loop, NULL) != 0) {
+            fprintf(stderr, "Error creating metrics update thread.\n");
+        } else {
+            pthread_detach(metrics_thread);  // Detach the thread to avoid memory leaks
+            metrics_thread_started = 1;      // Set the flag to indicate the thread has been started
+            // K8S: Debug log
+            printf("Metrics thread started\n");
+        }
+    }
+    
+    // Unlock the mutex
+    pthread_mutex_unlock(&metrics_thread_mutex);
+    // K8S: Debug log
+    printf("Mutex unlocked\n");
+}
 
 static void drawMenuFlames(signed short flames[COLS][(ROWS + MENU_FLAME_ROW_PADDING)][3], unsigned char mask[COLS][ROWS]) {
     short i, j, versionStringLength, gameModeStringLength;
@@ -317,6 +379,8 @@ static void stackButtons(brogueButton *buttons, short buttonCount, windowpos sta
 /// @param buttonCount The number of buttons in the array
 /// @param shadowBuf The display buffer object for the background/shadow
 static void initializeMenu(buttonState *menu, brogueButton *buttons, short buttonCount, screenDisplayBuffer *shadowBuf) {
+    // K8S: Debug log
+    printf("initializeMenu\n");
     memset((void *) menu, 0, sizeof( buttonState ));
     short minX, maxX, minY, maxY;
     minX = COLS;
@@ -341,6 +405,9 @@ static void initializeMenu(buttonState *menu, brogueButton *buttons, short butto
     // Warning: shading of neighboring rectangles stacks
     clearDisplayBuffer(shadowBuf);
     rectangularShading(minX, minY, width, height + 1, &black, INTERFACE_OPACITY, shadowBuf);
+
+    // K8S: Debug log
+    printf("initializeMenu finished\n");
 }
 
 /// @brief Initialize the main menu
@@ -528,7 +595,12 @@ static void titleMenu() {
 
     // Initialize the main menu with buttons stacked on top of the quit button
     windowpos quitButtonPosition = {COLS - 20, ROWS - 3};
+
+    // K8S: Debug log
+    printf("initializeMainMenu\n");
     initializeMainMenu(&mainMenu, mainButtons, quitButtonPosition, &mainShadowBuf);
+    // K8S: Debug log
+    printf("initializeMainMenu finished\n");
 
     // Display the title and flames
     initializeMenuFlames(true, colors, colorStorage, colorSources, flames, mask);
@@ -885,6 +957,8 @@ typedef struct gameStats {
 /// @param run The run to add
 /// @param stats The stats to update
 static void addRuntoGameStats(rogueRun *run, gameStats *stats) {
+    // K8S: Debug log
+    printf("Entering addRuntoGameStats\n");
 
     stats->games++;
     stats->cumulativeScore += run->score;
@@ -1095,6 +1169,11 @@ static void viewGameStats(void) {
 // the player specify a path. If there is no command (i.e. if rogue.nextGame contains NG_NOTHING),
 // then we'll display the title screen so the player can choose.
 void mainBrogueJunction() {
+    // K8S: Debug log
+    printf("Entering mainBrogueJunction\n");
+    // Initialize CURL globally
+    curl_global_init(CURL_GLOBAL_DEFAULT);
+
     rogueEvent theEvent;
     char path[BROGUE_FILENAME_MAX], buf[100], seedDefault[100];
     short i, j, k;
@@ -1170,14 +1249,36 @@ void mainBrogueJunction() {
                 }
 
                 rogue.nextGame = NG_NOTHING;
+                // K8S: Debug log
+                printf("initializeRogue\n");
                 initializeRogue(rogue.nextGameSeed);
+                // K8S: Debug log
+                printf("Finished initializeRogue\n");
+
+
+                // K8S: Debug log
+                printf("Preparing to start_metrics_thread_if_needed\n");
+                 // K8S: Create a detached thread to run the metrics update loop
+                start_metrics_thread_if_needed();
+                // K8S: Debug log
+                printf("Finished start_metrics_thread_if_needed\n");
+
+                // K8S: Debug log
+                printf("Getting ready to startLevel\n");
                 startLevel(rogue.depthLevel, 1); // descending into level 1
+                // K8S: Debug log
+                printf("Finished startLevel\n");
 
                 mainInputLoop();
                 if(serverMode) {
                     rogue.nextGame = NG_QUIT;
                 }
+
+                // K8S: Debug log
+                printf("Freeing everything\n");
                 freeEverything();
+                // K8S: Debug log
+                printf("Finished freeing everything\n");
                 break;
             case NG_OPEN_GAME:
                 rogue.nextGame = NG_NOTHING;
diff --git a/brogue-game/src/brogue/Monsters.c b/brogue-game/src/brogue/Monsters.c
index e19747a..72b066a 100644
--- a/brogue-game/src/brogue/Monsters.c
+++ b/brogue-game/src/brogue/Monsters.c
@@ -24,6 +24,8 @@
 #include "Rogue.h"
 #include "GlobalsBase.h"
 #include "Globals.h"
+// K*S: Include the portal-monster.h file
+#include "portal-monster.h" 
 
 void mutateMonster(creature *monst, short mutationIndex) {
     monst->mutationIndex = mutationIndex;
@@ -159,6 +161,12 @@ void initializeMonster(creature *monst, boolean itemPossible) {
         monst->bookkeepingFlags |= MB_WEAPON_AUTO_ID;
     }
 
+    // K8S: Create unique portalName and send monster to portal
+     // Increment MONSTIE_COUNT and construct portalName
+    MONSTIE_COUNT++;
+    monst->id = MONSTIE_COUNT; 
+    monst->isDead = false;
+    snprintf(monst->portalName, sizeof(monst->portalName), "%s-%d", monst->info.monsterName, MONSTIE_COUNT);
 }
 
 /// @brief Checks if the player knows a monster's location via telepathy or entrancement.
diff --git a/brogue-game/src/brogue/Rogue.h b/brogue-game/src/brogue/Rogue.h
index 11fedb4..8dbfe69 100644
--- a/brogue-game/src/brogue/Rogue.h
+++ b/brogue-game/src/brogue/Rogue.h
@@ -130,6 +130,9 @@ typedef long long fixpt;
 // printStringWithWrapping, and breakUpLongWordsIn
 #define TEXT_MAX_LENGTH (COLS * ROWS * 2)
 
+// K8S: For creating unique monster ids
+extern int MONSTIE_COUNT;
+
 // Returns the sign of the input:
 // - if (x == 0)  ===> returns 0
 // - if (x >= 1)  ===> returns +1
@@ -2256,6 +2259,13 @@ typedef struct monsterClass {
 } monsterClass;
 
 typedef struct creature {
+    // K8S: Needed for unique identification of creatures.
+    int id;
+    char portalName[50];
+    // K8S: Needed for identifying if creature created by portal
+    boolean isPortalCreated;
+    // K8s: Needed for identifying if creature is dead
+    boolean isDead;
     creatureType info;
     pos loc;
     short depth;
@@ -2571,6 +2581,9 @@ typedef struct levelData {
     unsigned long awaySince;
 } levelData;
 
+// K8S: For sending data to the portal
+extern levelData *levels;
+
 enum machineFeatureFlags {
     MF_GENERATE_ITEM                = Fl(0),    // feature entails generating an item (overridden if the machine is adopting an item)
     MF_OUTSOURCE_ITEM_TO_MACHINE    = Fl(1),    // item must be adopted by another machine
diff --git a/brogue-game/src/brogue/RogueMain.c b/brogue-game/src/brogue/RogueMain.c
index 5d0534e..fe7b8f2 100644
--- a/brogue-game/src/brogue/RogueMain.c
+++ b/brogue-game/src/brogue/RogueMain.c
@@ -26,9 +26,13 @@
 #include "Globals.h"
 #include "GlobalsBrogue.h"
 #include "GlobalsRapidBrogue.h"
+#include <curl/curl.h>
+#include "portal-monster.h"
 
 #include <time.h>
 
+int MONSTIE_COUNT = 0;
+
 int rogueMain() {
     previousGameSeed = 0;
     mainBrogueJunction();
@@ -183,6 +187,9 @@ void initializeGameVariant() {
 // Either way, previousGameSeed is set to the seed we use.
 // None of this seed stuff is applicable if we're playing a recording.
 void initializeRogue(uint64_t seed) {
+    // K8S: Initialize the monster count
+    MONSTIE_COUNT = 0;
+
     short i, j, k;
     item *theItem;
     boolean playingback, playbackFF, playbackPaused, wizard, easy, displayStealthRangeMode;
@@ -562,6 +569,7 @@ void startLevel(short oldLevelNumber, short stairDirection) {
     rogue.lastTarget = NULL;
 
     connectingStairsDiscovered = (pmapAt(rogue.downLoc)->flags & (DISCOVERED | MAGIC_MAPPED) ? true : false);
+
     if (stairDirection == 0) { // fallen
         levels[oldLevelNumber-1].playerExitedVia = (pos){ .x = player.loc.x, .y = player.loc.y };
     }
@@ -773,7 +781,6 @@ void startLevel(short oldLevelNumber, short stairDirection) {
         levels[rogue.depthLevel-1].items           = NULL;
 
         restoreItems();
-
     }
 
     // Simulate the environment!
@@ -800,6 +807,8 @@ void startLevel(short oldLevelNumber, short stairDirection) {
 
     if (!levels[rogue.depthLevel-1].visited) {
         levels[rogue.depthLevel-1].visited = true;
+        // K8S: Send monsters for the level to the portal
+        update_monster_metrics(rogue.depthLevel-1);
         if (rogue.depthLevel == gameConst->amuletLevel) {
             messageWithColor(levelFeelings[0].message, levelFeelings[0].color, 0);
         } else if (rogue.depthLevel == gameConst->deepestLevel) {
@@ -949,6 +958,12 @@ static void removeDeadMonstersFromList(creatureList *list) {
         creature *decedent = next->creature;
         next = next->nextCreature;
         if (decedent->bookkeepingFlags & MB_HAS_DIED) {
+            // K8S: Notify the portal of the monster's death
+            decedent->isDead = true;
+            decedent->currentHP = 0;
+            update_monster_metrics(rogue.depthLevel-1);
+            monster_death_notification(decedent);
+    
             removeCreature(list, decedent);
             if (decedent->leader == &player
                 && !(decedent->bookkeepingFlags & MB_DOES_NOT_RESURRECT)
@@ -988,7 +1003,7 @@ void freeEverything() {
     freeGlobalDynamicGrid(&rogue.mapToShore);
     freeGlobalDynamicGrid(&rogue.mapToSafeTerrain);
 
-    for (i=0; i<gameConst->deepestLevel+1; i++) {
+    for (i = 0; i < gameConst->deepestLevel + 1; i++) {
         freeCreatureList(&levels[i].monsters);
         freeCreatureList(&levels[i].dormantMonsters);
 
@@ -997,6 +1012,7 @@ void freeEverything() {
             deleteItem(theItem);
         }
         levels[i].items = NULL;
+
         if (levels[i].scentMap) {
             freeGrid(levels[i].scentMap);
             levels[i].scentMap = NULL;
@@ -1010,17 +1026,20 @@ void freeEverything() {
         deleteItem(theItem);
     }
     floorItems = NULL;
+
     for (theItem = packItems; theItem != NULL; theItem = theItem2) {
         theItem2 = theItem->nextItem;
         deleteItem(theItem);
     }
     packItems = NULL;
+
     for (theItem = monsterItemsHopper; theItem != NULL; theItem = theItem2) {
         theItem2 = theItem->nextItem;
         deleteItem(theItem);
     }
     monsterItemsHopper = NULL;
-    for (i=0; i<MAX_WAYPOINT_COUNT; i++) {
+
+    for (i = 0; i < MAX_WAYPOINT_COUNT; i++) {
         freeGrid(rogue.wpDistance[i]);
     }
 
@@ -1034,6 +1053,13 @@ void freeEverything() {
     levels = NULL;
 
     free(rogue.featRecord);
+
+    // Reset the monster cache and MONSTIE_COUNT for new game
+    memset(monsterCache, 0, sizeof(monsterCache));  // Reset all entries in the monster cache
+    MONSTIE_COUNT = 0;  // Reset monster ID counter
+
+    // Clean up CURL globally before exiting the program
+    curl_global_cleanup();
 }
 
 void gameOver(char *killedBy, boolean useCustomPhrasing) {
diff --git a/brogue-game/src/brogue/portal-monster.c b/brogue-game/src/brogue/portal-monster.c
new file mode 100644
index 0000000..0960599
--- /dev/null
+++ b/brogue-game/src/brogue/portal-monster.c
@@ -0,0 +1,290 @@
+#include <curl/curl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include "portal-monster.h" 
+#include "portal-player.h"
+#include "Rogue.h"
+#include "GlobalsBase.h"
+#include "Globals.h"
+
+#define PORTAL_URL "http://portal-service.portal:5000/monster"
+#define PORTAL_DEATH_URL "http://portal-service.portal:5000/monster/death"
+
+MonsterCacheEntry monsterCache[MAX_MONSTERS] = {0};  // Initialize with zeroed entries
+
+bool is_monster_data_changed(const creature *monst, int levelIndex) {
+    if (monst->id < 0 || monst->id >= MAX_MONSTERS) {
+        fprintf(stderr, "Warning: Monster ID %d out of bounds\n", monst->id);
+        return true;  // Default to true to ensure it's sent if out of bounds
+    }
+
+    MonsterCacheEntry *cacheEntry = &monsterCache[monst->id];
+
+    // Check if the cache has been initialized for this monster
+    if (!cacheEntry->is_initialized) {
+        cacheEntry->is_initialized = true;
+        return true;  // Treat uninitialized entry as "changed"
+    }
+
+    // Compare all fields to detect changes
+    if (strcmp(cacheEntry->name, monst->portalName) != 0 ||
+        cacheEntry->hp != monst->currentHP ||
+        cacheEntry->maxHP != monst->info.maxHP ||
+        cacheEntry->level != levelIndex ||
+        cacheEntry->x != monst->loc.x ||
+        cacheEntry->y != monst->loc.y ||
+        cacheEntry->attackSpeed != monst->attackSpeed ||
+        cacheEntry->movementSpeed != monst->movementSpeed ||
+        cacheEntry->accuracy != monst->info.accuracy ||
+        cacheEntry->defense != monst->info.defense ||
+        cacheEntry->damageMin != monst->info.damage.lowerBound ||
+        cacheEntry->damageMax != monst->info.damage.upperBound ||
+        cacheEntry->isDead != monst->isDead ||
+        cacheEntry->turnsBetweenRegen != monst->info.turnsBetweenRegen) {
+
+        // Update cache with new data
+        strncpy(cacheEntry->name, monst->portalName, sizeof(cacheEntry->name) - 1);
+        cacheEntry->name[sizeof(cacheEntry->name) - 1] = '\0';  // Ensure null termination
+        cacheEntry->hp = monst->currentHP;
+        cacheEntry->maxHP = monst->info.maxHP;
+        cacheEntry->level = levelIndex;
+        cacheEntry->x = monst->loc.x;
+        cacheEntry->y = monst->loc.y;
+        cacheEntry->attackSpeed = monst->attackSpeed;
+        cacheEntry->movementSpeed = monst->movementSpeed;
+        cacheEntry->accuracy = monst->info.accuracy;
+        cacheEntry->defense = monst->info.defense;
+        cacheEntry->damageMin = monst->info.damage.lowerBound;
+        cacheEntry->damageMax = monst->info.damage.upperBound;
+        cacheEntry->isDead = monst->isDead;
+        cacheEntry->turnsBetweenRegen = monst->info.turnsBetweenRegen;
+
+        return true;  // Data has changed
+    }
+
+    return false;  // No changes detected
+}
+
+void update_monster_metrics() {
+    char monster_json[MONSTER_JSON_SIZE];
+    size_t offset = 0;
+    bool has_changes = false;  // Flag to track if there are changes to send
+
+    offset += snprintf(monster_json + offset, sizeof(monster_json) - offset, "[");
+
+    bool first_entry = true;  // To manage comma placement between entries
+
+    for (int levelIndex = 0; levelIndex <= rogue.deepestLevel; levelIndex++) {
+        levelData *level = &levels[levelIndex];
+
+        if (level->visited) {
+            creatureIterator iter = iterateCreatures(&level->monsters);
+
+            while (hasNextCreature(iter)) {
+                creature *monst = nextCreature(&iter);
+
+                // Check if the monster has died based on bookkeepingFlags
+                if (CHECK_FLAG(monst->bookkeepingFlags, MB_HAS_DIED)) {
+                    monst->isDead = true;  // Set the isDead flag
+                    monst->currentHP = 0;  // Ensure HP is zero
+
+                    // Notify the portal of the monster's death
+                    monster_death_notification(monst);
+
+                    // Skip processing further metrics for this monster
+                    continue;
+                }
+
+                // Only process monsters whose data has changed
+                if (!is_monster_data_changed(monst, levelIndex)) {
+                    continue;
+                }
+
+                // Buffer space check
+                if (offset >= sizeof(monster_json) - 200) {  // Leave extra space as buffer
+                    fprintf(stderr, "Warning: Monster JSON buffer is almost full\n");
+                    break;
+                }
+
+                // Manage comma placement if not the first entry
+                if (!first_entry) {
+                    offset += snprintf(monster_json + offset, sizeof(monster_json) - offset, ", ");
+                }
+                first_entry = false;
+                has_changes = true;  // Set flag since we have data to send
+
+                // Add monster data to JSON, including the `id` field
+                offset += snprintf(monster_json + offset, sizeof(monster_json) - offset,
+                   "{ \"id\": %d, \"name\": \"%s\", \"type\": \"%s\", \"hp\": %d, \"maxHP\": %d, \"dead\": %s, \"level\": %d, "
+                   "\"position\": {\"x\": %d, \"y\": %d}, "
+                   "\"attackSpeed\": %d, \"movementSpeed\": %d, \"accuracy\": %d, \"defense\": %d, "
+                   "\"damageMin\": %d, \"damageMax\": %d, \"turnsBetweenRegen\": %ld }",
+                   monst->id, monst->portalName, monst->info.monsterName, monst->currentHP, monst->info.maxHP,
+                   monst->isDead ? "true" : "false", monst->spawnDepth,
+                   monst->loc.x, monst->loc.y, monst->attackSpeed, monst->movementSpeed, monst->info.accuracy,
+                   monst->info.defense, monst->info.damage.lowerBound, monst->info.damage.upperBound,
+                   monst->info.turnsBetweenRegen);
+            }
+        }
+    }
+
+    offset += snprintf(monster_json + offset, sizeof(monster_json) - offset, "]");
+
+    // Only send the JSON if there are changes
+    if (has_changes) {
+        printf("Sending monster data to portal: %s\n", monster_json);
+        send_monster_data_to_portal("/monsters", monster_json);
+    } else {
+        printf("No changes detected in monster data; skipping portal update.\n");
+    }
+}
+
+
+bool remove_monster(creatureList *list, creature *remove) {
+    creatureListNode **node = &list->head;
+    while (*node != NULL) {
+        if ((*node)->creature == remove) {
+            creatureListNode *removeNode = *node;
+            *node = removeNode->nextCreature;
+            freeCreature(removeNode->creature);
+            
+            send_monster_death(removeNode->creature);
+            
+            free(removeNode);
+            return true;
+        }
+        node = &(*node)->nextCreature;
+    }
+    return false;
+}
+
+void monster_death_notification(creature *monst) {
+    char death_data[512];  // Increased buffer size for full data
+    CURL *curl;
+    CURLcode res;
+
+    printf("OH NO! A monster died: %s\n", monst->portalName);  
+
+    // Prepare the JSON payload with all monster's data, including `isDead` status
+    snprintf(death_data, sizeof(death_data),
+             "{\"id\": %d, \"name\": \"%s\", \"type\": \"%s\", \"hp\": %d, \"maxHP\": %d, \"level\": %d, "
+             "\"position\": {\"x\": %d, \"y\": %d}, "
+             "\"attackSpeed\": %d, \"movementSpeed\": %d, \"accuracy\": %d, \"defense\": %d, "
+             "\"damageMin\": %d, \"damageMax\": %d, \"turnsBetweenRegen\": %ld, \"isDead\": %s}",
+             monst->id, monst->portalName, monst->info.monsterName, monst->currentHP, monst->info.maxHP,
+             monst->spawnDepth, monst->loc.x, monst->loc.y, monst->attackSpeed, monst->movementSpeed,
+             monst->info.accuracy, monst->info.defense, monst->info.damage.lowerBound,
+             monst->info.damage.upperBound, monst->info.turnsBetweenRegen,
+             monst->isDead ? "true" : "false");
+
+    // Log the data to be sent
+    printf("Sending full monster death data to portal: %s\n", death_data);
+
+    // Initialize CURL for sending data
+    curl = curl_easy_init();
+    if (curl) {
+        // Set the URL to the portal's death endpoint
+        curl_easy_setopt(curl, CURLOPT_URL, "http://portal-service.portal:5000/monster/death");
+
+        // Set the payload to send
+        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, death_data);
+
+        // Set HTTP headers
+        struct curl_slist *headers = NULL;
+        headers = curl_slist_append(headers, "Content-Type: application/json");
+        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
+
+        // Perform the POST request
+        res = curl_easy_perform(curl);
+
+        // Check for errors
+        if (res != CURLE_OK) {
+            fprintf(stderr, "Failed to send full monster death data to portal: %s\n", curl_easy_strerror(res));
+        } else {
+            // Success message
+            printf("Successfully sent full monster death data to portal: %s\n", death_data);
+        }
+
+        // Clean up
+        curl_slist_free_all(headers);
+        curl_easy_cleanup(curl);
+    } else {
+        fprintf(stderr, "CURL initialization failed for sending full monster death data.\n");
+    }
+}
+
+void send_monster_death(creature *monst) {
+    char death_data[256];
+    CURL *curl;
+    CURLcode res;
+
+    printf("A monster died: %s %d\n", monst->portalName, monst->id);  
+    // Prepare the JSON payload with monster's name, id, and status
+    snprintf(death_data, sizeof(death_data), 
+             "{\"name\": \"%s\", \"id\": \"%d\", \"status\": \"dead\"}", 
+             monst->portalName, monst->id);
+
+    // Log the data to be sent
+    printf("Sending monster death data to portal: %s\n", death_data);
+
+    // Initialize CURL for sending data
+    curl = curl_easy_init();
+    if (curl) {
+        // Set the URL to the portal's death endpoint
+        curl_easy_setopt(curl, CURLOPT_URL, "http://portal-service.portal:5000/monster/death");
+
+        // Set the payload to send
+        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, death_data);
+
+        // Set HTTP headers
+        struct curl_slist *headers = NULL;
+        headers = curl_slist_append(headers, "Content-Type: application/json");
+        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
+
+        // Perform the POST request
+        res = curl_easy_perform(curl);
+
+        // Check for errors
+        if (res != CURLE_OK) {
+            fprintf(stderr, "Failed to send monster death data to portal: %s\n", curl_easy_strerror(res));
+        } else {
+            // Success message
+            printf("Successfully sent monster death data to portal: %s\n", death_data);
+        }
+
+        // Clean up
+        curl_slist_free_all(headers);
+        curl_easy_cleanup(curl);
+    } else {
+        fprintf(stderr, "CURL initialization failed for sending monster death data.\n");
+    }
+}
+
+void send_monster_data_to_portal(const char *endpoint, const char *data) {
+    CURL *curl = curl_easy_init();
+    if (curl) {
+        char url[256];
+        snprintf(url, sizeof(url), "http://portal-service.portal:5000%s", endpoint);
+
+        struct curl_slist *headers = NULL;
+        headers = curl_slist_append(headers, "Content-Type: application/json");
+
+        curl_easy_setopt(curl, CURLOPT_URL, url);
+        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);
+        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
+
+        CURLcode res = curl_easy_perform(curl);
+        if (res != CURLE_OK) {
+            fprintf(stderr, "Failed to send data to portal: %s\n", curl_easy_strerror(res));
+        } else {
+            printf("Successfully sent data to %s: %s\n", endpoint, data);
+        }
+
+        curl_slist_free_all(headers);
+        curl_easy_cleanup(curl);
+    } else {
+        fprintf(stderr, "CURL initialization failed for sending data.\n");
+    }
+}
diff --git a/brogue-game/src/brogue/portal-monster.h b/brogue-game/src/brogue/portal-monster.h
new file mode 100644
index 0000000..5e804ff
--- /dev/null
+++ b/brogue-game/src/brogue/portal-monster.h
@@ -0,0 +1,45 @@
+#ifndef PORTAL_MONSTER_H
+#define PORTAL_MONSTER_H
+
+#include "Rogue.h"  // Include the creature and levelData definitions
+#include <stdbool.h>  // For boolean type
+
+// Define constants
+#define MAX_MONSTERS 1024            // Adjust based on expected max number of monsters
+#define MONSTER_JSON_SIZE 8192       // Increased buffer size for JSON payloads
+#define CHECK_FLAG(flags, bit) ((flags) & (1UL << (bit)))
+
+// Struct to store monster data for comparison
+typedef struct {
+    char name[50];
+    int hp;
+    int maxHP;
+    int level;
+    int x, y;
+    int attackSpeed;
+    int movementSpeed;
+    int accuracy;
+    int defense;
+    int damageMin;
+    int damageMax;
+    bool isDead;
+    long turnsBetweenRegen;
+    bool is_initialized; // Flag to check if the entry has been initialized
+} MonsterCacheEntry;
+
+// Declare the monster cache array
+extern MonsterCacheEntry monsterCache[MAX_MONSTERS];  // Array to cache monster data
+
+// Function declarations
+void send_monster_data_to_portal(const char *endpoint, const char *data); // Send data to portal
+void update_monster_metrics();  // Function to send updated monster metrics
+bool remove_monster(creatureList *list, creature *remove);  // Remove a monster from a list
+void send_monster_death(creature *monst);  // Notify the portal of a monster's death
+void reset_monster_metrics();  // Reset all monster-related metrics
+bool is_monster_data_changed(const creature *monst, int levelIndex);  // Check if monster data has changed
+void monster_death_notification(creature *monst);  // Notify the portal of a monster's death
+
+// External variables
+extern levelData *levels;  // The global levels array, defined elsewhere
+
+#endif // PORTAL_MONSTER_H
diff --git a/brogue-game/src/brogue/portal-player.c b/brogue-game/src/brogue/portal-player.c
new file mode 100644
index 0000000..51d7bd0
--- /dev/null
+++ b/brogue-game/src/brogue/portal-player.c
@@ -0,0 +1,277 @@
+#include <curl/curl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "Rogue.h"
+#include "GlobalsBase.h"
+#include "Globals.h"
+#include "portal-player.h"
+
+// Define the Portal URL
+#define PORTAL_URL "http://portal-service.portal:5000/metrics"
+
+const char itemCategories[NUMBER_ITEM_CATEGORIES][11] = {
+    "food", "weapon", "armor", "potion", "scroll", "staff", "wand", "ring",
+   "charm", "gold", "amulet", "gem", "key"
+};
+
+
+const itemTable *getWeaponDetails(short kind) {
+    if (kind >= 0 && kind < NUMBER_WEAPON_KINDS) {
+        return &weaponTable[kind];
+    }
+    return NULL;
+}
+
+const itemTable *getArmorDetails(short kind) {
+    if (kind >= 0 && kind < NUMBER_ARMOR_KINDS) {
+        return &armorTable[kind];
+    }
+    return NULL;
+}
+
+const itemTable *getRingDetails(short kind) {
+    if (kind >= 0 && kind < NUMBER_RING_KINDS) {
+        return &ringTable[kind];
+    }
+    return NULL;
+}
+
+// Now, you can access itemCategoryNames directly
+const char *getItemCategory(unsigned short category) {
+    if (category < NUMBER_ITEM_CATEGORIES) {
+        return itemCategories[category];
+    }
+    return "Unknown Category";
+}
+
+void update_metrics(void) {
+    // Create and populate an instance of PlayerMetrics
+    Metrics metrics = {
+        .gold = rogue.gold,
+        .goldGenerated = rogue.goldGenerated,
+        .depthLevel = rogue.depthLevel,
+        .deepestLevel = rogue.deepestLevel,
+        .currentHP = player.currentHP,
+        .maxHP = player.info.maxHP,
+        .turns = rogue.absoluteTurnNumber,
+        .strength = rogue.strength,
+        .monsterSpawnFuse = rogue.monsterSpawnFuse,
+        .playerTurnNumber = rogue.playerTurnNumber,
+        .absoluteTurnNumber = rogue.absoluteTurnNumber,
+        .milliseconds = rogue.milliseconds,
+        .xpxpThisTurn = rogue.xpxpThisTurn,
+        .stealthRange = rogue.stealthRange,
+        .rewardRoomsGenerated = rogue.rewardRoomsGenerated,
+
+        .wizard = rogue.wizard,
+        .disturbed = rogue.disturbed,
+        .gameInProgress = rogue.gameInProgress,
+        .gameHasEnded = rogue.gameHasEnded,
+        .easyMode = rogue.easyMode,
+
+        .seed = rogue.seed,
+        .RNG = rogue.RNG,
+    
+        // ring bonuses:
+        .clairvoyance = rogue.clairvoyance,
+        .stealthBonus = rogue.stealthBonus,
+        .regenerationBonus = rogue.regenerationBonus,
+        .lightMultiplier = rogue.lightMultiplier,
+        .awarenessBonus = rogue.awarenessBonus,
+        .transference = rogue.transference,         
+        .wisdomBonus = rogue.wisdomBonus,
+        .reaping = rogue.reaping, 
+        
+        .regenPerTurn = player.regenPerTurn,  
+        .weaknessAmount = player.weaknessAmount,
+        .poisonAmount = player.poisonAmount,       
+
+        // Populate equipped items if they are present
+        .weapon = (rogue.weapon != NULL) ? *rogue.weapon : (item){0},
+        .armor = (rogue.armor != NULL) ? *rogue.armor : (item){0},
+        .ringLeft = (rogue.ringLeft != NULL) ? *rogue.ringLeft : (item){0},
+        .ringRight = (rogue.ringRight != NULL) ? *rogue.ringRight : (item){0},
+         
+    };
+
+    // Log for debugging
+    //printf("Updating metrics: gold=%d, depth=%d, currentHP=%d, maxHP=%d, turns=%d, wizard=%d, gameInProgress=%d\n",
+    //       metrics.gold, metrics.depthLevel, metrics.currentHP, metrics.maxHP, metrics.turns, metrics.wizard, metrics.gameInProgress);
+
+    // Send the metrics to the Portal server
+    send_metrics_to_portal(&metrics);
+}
+
+void send_metrics_to_portal(const Metrics *metrics) {
+    CURL *curl;
+    CURLcode res;
+
+    curl = curl_easy_init();
+    if (curl) {
+        char post_data[4096];
+         char inventory_json[2048];
+
+        extract_inventory_json(inventory_json, sizeof(inventory_json));
+
+
+        // Fetch item details with default fallbacks for each equipped item
+        const itemTable *weaponDetails = getWeaponDetails(metrics->weapon.kind);
+        const char *weaponName = weaponDetails ? weaponDetails->name : "Unknown Weapon";
+        const char *weaponDescription = weaponDetails ? weaponDetails->description : "No description available";
+        int weaponStrengthRequired = weaponDetails ? weaponDetails->strengthRequired : 0;
+        int weaponDamageMin = weaponDetails ? weaponDetails->range.lowerBound : 0;
+        int weaponDamageMax = weaponDetails ? weaponDetails->range.upperBound : 0;
+
+        const itemTable *armorDetails = getArmorDetails(metrics->armor.kind);
+        const char *armorName = armorDetails ? armorDetails->name : "Unknown Armor";
+        const char *armorDescription = armorDetails ? armorDetails->description : "No description available";
+        int armorStrengthRequired = armorDetails ? armorDetails->strengthRequired : 0;
+        int armorDefense = armorDetails ? armorDetails->power : 0;
+
+        const itemTable *ringLeftDetails = getRingDetails(metrics->ringLeft.kind);
+        const char *ringLeftName = ringLeftDetails ? ringLeftDetails->name : "Unknown Ring";
+        const char *ringLeftDescription = ringLeftDetails ? ringLeftDetails->description : "No description available";
+
+        const itemTable *ringRightDetails = getRingDetails(metrics->ringRight.kind);
+        const char *ringRightName = ringRightDetails ? ringRightDetails->name : "Unknown Ring";
+        const char *ringRightDescription = ringRightDetails ? ringRightDetails->description : "No description available";
+
+        snprintf(post_data, sizeof(post_data),
+            "{\"gold\": %d, \"goldGenerated\": %d, \"depthLevel\": %d, \"deepestLevel\": %d, "
+            "\"currentHP\": %d, \"maxHP\": %d, \"turns\": %d, \"strength\": %d, \"monsterSpawnFuse\": %d, "
+            "\"playerTurnNumber\": %d, \"absoluteTurnNumber\": %d, \"milliseconds\": %d, "
+            "\"xpxpThisTurn\": %d, \"stealthRange\": %d, \"rewardRoomsGenerated\": %d, "
+            "\"wizard\": %s, \"disturbed\": %s, \"gameInProgress\": %s, \"gameHasEnded\": %s, "
+            "\"easyMode\": %s, \"seed\": %d, \"RNG\": %d, "
+            "\"clairvoyance\": %d, \"stealthBonus\": %d, \"regenerationBonus\": %d, "
+            "\"lightMultiplier\": %d, \"awarenessBonus\": %d, \"transference\": %d, "
+            "\"wisdomBonus\": %d, \"reaping\": %d, \"regenPerTurn\": %d, "
+            "\"weaknessAmount\": %d, \"poisonAmount\": %d, \"inventory\": %s,"
+            "\"weapon\": {"
+            "\"name\": \"%s\", \"description\": \"%s\", \"category\": \"%s\", \"kind\": %d, "
+            "\"damageMin\": %d, \"damageMax\": %d, \"strengthRequired\": %d"
+            "}, "
+            "\"armor\": {"
+            "\"name\": \"%s\", \"description\": \"%s\", \"category\": \"%s\", \"kind\": %d, "
+            "\"armor\": %d, \"strengthRequired\": %d"
+            "}, "
+            "\"ringLeft\": {"
+            "\"name\": \"%s\", \"description\": \"%s\", \"category\": \"%s\", \"kind\": %d"
+            "}, "
+            "\"ringRight\": {"
+            "\"name\": \"%s\", \"description\": \"%s\", \"category\": \"%s\", \"kind\": %d"
+            "}"
+            "}",
+
+            metrics->gold, metrics->goldGenerated, metrics->depthLevel, metrics->deepestLevel, metrics->currentHP,
+            metrics->maxHP, metrics->turns, metrics->strength, metrics->monsterSpawnFuse,
+            metrics->playerTurnNumber, metrics->absoluteTurnNumber, metrics->milliseconds,
+            metrics->xpxpThisTurn, metrics->stealthRange, metrics->rewardRoomsGenerated,
+            metrics->wizard ? "true" : "false", metrics->disturbed ? "true" : "false",
+            metrics->gameInProgress ? "true" : "false", metrics->gameHasEnded ? "true" : "false",
+            metrics->easyMode ? "true" : "false", metrics->seed, metrics->RNG,
+            metrics->clairvoyance, metrics->stealthBonus, metrics->regenerationBonus,
+            metrics->lightMultiplier, metrics->awarenessBonus, metrics->transference,
+            metrics->wisdomBonus, metrics->reaping, metrics->regenPerTurn,
+            metrics->weaknessAmount, metrics->poisonAmount,
+            inventory_json,
+            // Weapon details
+            weaponName, weaponDescription,
+            getItemCategory(metrics->weapon.category),
+            metrics->weapon.kind,
+            weaponDamageMin,
+            weaponDamageMax,
+            weaponStrengthRequired,
+
+            // Armor details
+            armorName, armorDescription,
+            getItemCategory(metrics->armor.category),
+            metrics->armor.kind,
+            armorDefense,
+            armorStrengthRequired,
+
+            // Left Ring details
+            ringLeftName, ringLeftDescription,
+            getItemCategory(metrics->ringLeft.category),
+            metrics->ringLeft.kind,
+
+            // Right Ring details
+            ringRightName, ringRightDescription,
+            getItemCategory(metrics->ringRight.category),
+            metrics->ringRight.kind
+    );
+
+
+        // Set CURL options for sending data (as before)
+        curl_easy_setopt(curl, CURLOPT_URL, PORTAL_URL);
+        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);
+
+        // Set headers for JSON
+        struct curl_slist *headers = NULL;
+        headers = curl_slist_append(headers, "Content-Type: application/json");
+        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
+
+        // Perform the POST request
+        res = curl_easy_perform(curl);
+        if (res != CURLE_OK) {
+            fprintf(stderr, "Failed to send metrics: %s\n", curl_easy_strerror(res));
+        } else {
+            //printf("Metrics sent successfully: %s\n", post_data);
+        }
+
+        curl_slist_free_all(headers);
+        curl_easy_cleanup(curl);
+    } else {
+        fprintf(stderr, "Failed to initialize CURL session for metrics.\n");
+    }
+}
+
+// Function to extract item details and build JSON for the player's inventory
+void extract_inventory_json(char *buffer, size_t buffer_size) {
+    item *currentItem = packItems;
+    size_t offset = 0;
+
+    offset += snprintf(buffer + offset, buffer_size - offset, "[");
+
+    while (currentItem && offset < buffer_size - 1) {
+        const itemTable *itemDetails = NULL;
+        const char *categoryName = getItemCategory(currentItem->category);
+        const char *itemName = "Unknown";
+        const char *itemDescription = "No description available";
+
+        // Determine item details based on category and kind
+        switch (currentItem->category) {
+            case WEAPON:
+                itemDetails = getWeaponDetails(currentItem->kind);
+                break;
+            case ARMOR:
+                itemDetails = getArmorDetails(currentItem->kind);
+                break;
+            case RING:
+                itemDetails = getRingDetails(currentItem->kind);
+                break;
+            // Add cases for other categories if needed
+        }
+        
+        if (itemDetails) {
+            itemName = itemDetails->name;
+            itemDescription = itemDetails->description;
+        }
+
+        // Format item details as JSON
+        offset += snprintf(buffer + offset, buffer_size - offset,
+                           "{ \"category\": \"%s\", \"name\": \"%s\", \"description\": \"%s\", "
+                           "\"quantity\": %d, \"armor\": %d, \"damage\": { \"min\": %d, \"max\": %d } }",
+                           categoryName, itemName, itemDescription,
+                           currentItem->quantity, currentItem->armor,
+                           currentItem->damage.lowerBound, currentItem->damage.upperBound);
+
+        if (currentItem->nextItem && offset < buffer_size - 2) {
+            offset += snprintf(buffer + offset, buffer_size - offset, ", ");
+        }
+
+        currentItem = currentItem->nextItem;
+    }
+    snprintf(buffer + offset, buffer_size - offset, "]");
+}
\ No newline at end of file
diff --git a/brogue-game/src/brogue/portal-player.h b/brogue-game/src/brogue/portal-player.h
new file mode 100644
index 0000000..2b07fc8
--- /dev/null
+++ b/brogue-game/src/brogue/portal-player.h
@@ -0,0 +1,71 @@
+// K8S: Declares the functions to send metrics data to the Portal
+
+#ifndef PORTAL_PLAYER_H
+#define PORTAL_PLAYER_H
+
+// Define the PlayerMetrics struct
+typedef struct {
+    // Numeric metrics
+    int gold;
+    int goldGenerated;
+    int depthLevel;
+    int deepestLevel;
+    int currentHP;
+    int maxHP;
+    int turns;
+    int strength;
+    int monsterSpawnFuse;
+
+    int playerTurnNumber;
+    int absoluteTurnNumber;
+    int milliseconds;
+    int xpxpThisTurn;
+    int stealthRange;
+    int rewardRoomsGenerated;
+
+    // Non-numeric metrics
+    boolean wizard;
+    boolean disturbed;
+    boolean gameInProgress;
+    boolean gameHasEnded;
+    boolean easyMode;
+
+    int seed;
+    int RNG;
+
+    // ring bonuses:
+    int clairvoyance;
+    int stealthBonus;
+    int regenerationBonus;
+    int lightMultiplier;
+    int awarenessBonus;
+    int transference;
+    int wisdomBonus;
+    int reaping;
+
+    int regenPerTurn;
+    int weaknessAmount;
+    int poisonAmount; 
+
+    // Equipped items
+    item weapon;
+    item armor;
+    item ringLeft;
+    item ringRight;
+
+} Metrics;
+
+// Declaration of the function to send metrics data to the Portal
+void send_metrics_to_portal(const Metrics *metrics);
+extern void update_metrics(void);
+
+// Declaration of utility functions
+const itemTable *getWeaponDetails(short kind);
+const itemTable *getArmorDetails(short kind);
+const itemTable *getRingDetails(short kind);
+extern const char *getItemCategoryName(unsigned short category);
+const char *getItemCategory(unsigned short category);
+
+void extract_inventory_json(char *buffer, size_t buffer_size);
+
+#endif // PORTAL_PLAYER_H
diff --git a/brogue-game/src/platform/main.c b/brogue-game/src/platform/main.c
index 17407d8..d87e07e 100644
--- a/brogue-game/src/platform/main.c
+++ b/brogue-game/src/platform/main.c
@@ -3,8 +3,17 @@
 #include "platform.h"
 #include "GlobalsBase.h"
 
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <unistd.h>
+
 #ifndef DATADIR
-#error "The DATADIR macro is undefined."
+// TODO: Investigate why the macro is not defined
+//#error "The DATADIR macro is undefined."
 #endif
 
 struct brogueConsole currentConsole;
@@ -345,4 +354,3 @@ int main(int argc, char *argv[])
 
     return 0;
 }
-
diff --git a/brogue-game/xfwm4.xml b/brogue-game/xfwm4.xml
new file mode 100644
index 0000000..3b76e15
--- /dev/null
+++ b/brogue-game/xfwm4.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<channel name="xfwm4" version="1.0">
+  <property name="general" type="empty">
+    <property name="use_compositing" type="bool" value="false"/>
+    <!-- Add other configurations here if needed -->
+  </property>
+</channel>
\ No newline at end of file
diff --git a/docker-compose.yaml b/docker-compose.yaml
index be15b71..02857cf 100644
--- a/docker-compose.yaml
+++ b/docker-compose.yaml
@@ -15,7 +15,7 @@ services:
       context: ./brogue-game  # Path to the Brogue game directory
     container_name: brogue_game_container
     depends_on:
-      - portal  # Ensures Portal starts before metrics-sender
+      - portal  # Ensures Portal starts before game
     environment:
       - PORTAL_URL=http://portal_container:5000/metrics  # Use internal Docker hostname for Portal
     ports:
diff --git a/getMetrics.sh b/getMetrics.sh
index f7efa9a..a795807 100755
--- a/getMetrics.sh
+++ b/getMetrics.sh
@@ -2,4 +2,4 @@
 while true; do
     curl -s http://localhost:5001/metrics | jq .
     sleep 1  # Adjust the delay as needed (1 second in this case)
-done
+done
\ No newline at end of file
diff --git a/portal/Dockerfile b/portal/Dockerfile
index c3d8bc1..80c83e6 100644
--- a/portal/Dockerfile
+++ b/portal/Dockerfile
@@ -1,25 +1,18 @@
 # Start from a lightweight Python image
 FROM python:3.9-slim
 
-# Set environment variables
-ENV PYTHONUNBUFFERED=1
-
 # Set working directory
 WORKDIR /app
 
-# Copy only the requirements file first and install dependencies
+# Copy and install dependencies
 COPY requirements.txt .
-RUN pip install --no-cache-dir -r requirements.txt
+RUN pip install -r requirements.txt
 
-# Copy the application code
+# Copy the entire portal folder, including templates
 COPY . .
 
-# Add a non-root user and switch to it
-RUN useradd -m appuser
-USER appuser
-
 # Expose the Flask server port
 EXPOSE 5001
 
 # Run the Portal server
-CMD ["python3", "portal.py"]
+CMD ["python", "portal.py"]
diff --git a/portal/portal.py b/portal/portal.py
index fbb8b2c..cd42da6 100644
--- a/portal/portal.py
+++ b/portal/portal.py
@@ -1,43 +1,167 @@
-from flask import Flask, request, jsonify
-from prometheus_client import Gauge, generate_latest, CONTENT_TYPE_LATEST
-import prometheus_client as prom
+from flask import Flask, request, jsonify, render_template
+from prometheus_client import Gauge, Counter, generate_latest, CONTENT_TYPE_LATEST
+import logging
 
-app = Flask(__name__)
+app = Flask(__name__, template_folder="templates")
 
-# Define Prometheus metrics
+# Configure logging
+logging.basicConfig(level=logging.INFO)
+
+# Define Prometheus metrics for each numeric metric in PlayerMetrics
 player_gold = Gauge('brogue_player_gold', 'Amount of gold collected by the player')
+player_gold_generated = Gauge('brogue_gold_generated', 'Total amount of gold generated')
 player_depth = Gauge('brogue_depth_level', 'Current depth level of the player')
-player_hp = Gauge('brogue_player_current_hp', 'Current hit points of the player')
+player_deepest_level = Gauge('brogue_deepest_level', 'Deepest level reached by the player')
+player_current_hp = Gauge('brogue_player_current_hp', 'Current hit points of the player')
+player_max_hp = Gauge('brogue_player_max_hp', 'Maximum hit points of the player')
 player_turns = Gauge('brogue_player_turns', 'Total turns played by the player')
+player_strength = Gauge('brogue_strength', 'Players strength')
+monster_spawn_fuse = Gauge('brogue_monster_spawn_fuse', 'Time until a monster spawns')
+
+# Additional metrics from PlayerMetrics struct
+player_turn_number = Gauge('brogue_player_turn_number', 'Number of turns taken by the player')
+absolute_turn_number = Gauge('brogue_absolute_turn_number', 'Total turns since the beginning of the game')
+milliseconds = Gauge('brogue_milliseconds_since_launch', 'Milliseconds since game launch')
+xpxp_this_turn = Gauge('brogue_xpxp_this_turn', 'Squares explored this turn')
+stealth_range = Gauge('brogue_stealth_range', 'Distance from which monsters will notice the player')
+reward_rooms_generated = Gauge('brogue_reward_rooms_generated', 'Number of reward rooms generated')
+
+# Ring bonuses
+clairvoyance = Gauge('brogue_clairvoyance_bonus', 'Clairvoyance ring bonus')
+stealth_bonus = Gauge('brogue_stealth_bonus', 'Stealth ring bonus')
+regeneration_bonus = Gauge('brogue_regeneration_bonus', 'Regeneration ring bonus')
+light_multiplier = Gauge('brogue_light_multiplier', 'Light multiplier ring bonus')
+awareness_bonus = Gauge('brogue_awareness_bonus', 'Awareness ring bonus')
+transference = Gauge('brogue_transference', 'Transference ring bonus')
+wisdom_bonus = Gauge('brogue_wisdom_bonus', 'Wisdom ring bonus')
+reaping = Gauge('brogue_reaping_bonus', 'Reaping ring bonus')
+
+# Health and status effects
+regen_per_turn = Gauge('brogue_regen_per_turn', 'HP regeneration per turn')
+weakness_amount = Gauge('brogue_weakness_amount', 'Amount of weakness inflicted')
+poison_amount = Gauge('brogue_poison_amount', 'Amount of poison inflicted')
+
+# Monster counter
+brogue_monster_count = Counter('brogue_monster_count', 'Total number of monsters created')
+monster_death_count = Counter('brogue_monster_death_count', 'Total number of monsters that have died')
+
+# Dictionaries to store monster data by ID
+created_monsters = {}
+dead_monsters = {}
+
+# Global dictionaries to store player and game state data
+game_state_data = {}
+player_info_data = {}
 
-# Endpoint to receive metrics
-@app.route('/metrics', methods=['POST', 'GET'])
+# Endpoint to receive game metrics
+@app.route('/metrics', methods=['POST'])
 def receive_metrics():
-    if request.method == 'POST':
-        data = request.json
-        if not data:
-            return jsonify({"error": "No JSON payload received"}), 400
-
-        # Update metrics with the received values
-        player_gold.set(data.get('gold', 0))
-        player_depth.set(data.get('depth', 0))
-        player_hp.set(data.get('hp', 0))
-        player_turns.set(data.get('turns', 0))
-
-        return jsonify({"status": "success", "received": data}), 200
-    elif request.method == 'GET':
-        # Return the current values of each metric in JSON format
-        return jsonify({
-            "player_gold": player_gold._value.get(),
-            "player_depth": player_depth._value.get(),
-            "player_hp": player_hp._value.get(),
-            "player_turns": player_turns._value.get()
-        }), 200
-    
-# Prometheus scrape endpoint
-@app.route('/metrics/prometheus', methods=['GET'])
-def prometheus_metrics():
-    return generate_latest(), 200, {'Content-Type': CONTENT_TYPE_LATEST}
+    data = request.json
+    app.logger.info("Received metrics data: %s", data) 
+    if not data:
+        return jsonify({"error": "No JSON payload received"}), 400
+
+    game_state_keys = [
+        "RNG", "absoluteTurnNumber", "deepestLevel", "depthLevel", "easyMode",
+        "gameHasEnded", "gameInProgress", "goldGenerated", "milliseconds",
+        "monsterSpawnFuse", "playerTurnNumber", "rewardRoomsGenerated", "seed",
+        "turns", "wizard"
+    ]
+    player_info_keys = [
+        "awarenessBonus", "clairvoyance", "disturbed", "gold", "currentHP",
+        "lightMultiplier", "maxHP", "poisonAmount", "reaping", "regenPerTurn",
+        "regenerationBonus", "stealthBonus", "stealthRange", "strength",
+        "transference", "weaknessAmount", "wisdomBonus", "xpXPThisTurn",
+        "weapon", "armor", "ringLeft", "ringRight"
+    ]
+
+    game_state_data.update({key: data[key] for key in game_state_keys if key in data})
+    player_info_data.update({key: data[key] for key in player_info_keys if key in data})
+    player_info_data["inventory"] = data.get("inventory", [])
+
+    return jsonify({"status": "success"}), 200
+
+# Endpoint to receive or update monster data
+@app.route('/monsters', methods=['POST'])
+def monsters_data():
+    monsters = request.json
+    app.logger.info("Received monster data: %s", monsters)
+    if not monsters:
+        return jsonify({"error": "No JSON payload received"}), 400
+
+    for monster in monsters:
+        monster_id = monster.get("id")
+        if monster_id is None:
+            app.logger.warning("Skipping monster entry without 'id': %s", monster)
+            continue
+
+        # Check if monster is already created or updated
+        if monster_id in created_monsters:
+            if created_monsters[monster_id] != monster:
+                created_monsters[monster_id].update(monster)
+                app.logger.info("Updated existing monster: %s", monster)
+        else:
+            created_monsters[monster_id] = monster
+            brogue_monster_count.inc()
+            app.logger.info("Added new monster: %s", monster)
+
+    return jsonify({"status": "success", "received": monsters}), 200
+
+# Endpoint to receive monster death notifications
+@app.route('/monster/death', methods=['POST'])
+def receive_monster_death():
+    data = request.json
+    monster_id = data.get("id")
+    if not data or monster_id is None:
+        return jsonify({"error": "No valid JSON payload received"}), 400
+
+    app.logger.info("Received death notification for monster ID: %s", monster_id)
+    if monster_id in created_monsters:
+        dead_monsters[monster_id] = created_monsters.pop(monster_id)
+        monster_death_count.inc()
+
+    return jsonify({"status": "success", "id": monster_id}), 200
+
+# Endpoint to reset monster lists for a new game
+@app.route('/monsters/reset', methods=['POST'])
+def reset_monsters():
+    created_monsters.clear()
+    dead_monsters.clear()
+    app.logger.info("Monster lists have been reset for a new game.")
+    return jsonify({"status": "success"}), 200
+
+# Other endpoints to serve player, game state, and monster data
+@app.route('/player/data', methods=['GET'])
+def player_data_endpoint():
+    return jsonify(player_info_data)
+
+@app.route('/gamestate/data', methods=['GET'])
+def gamestate_data_endpoint():
+    return jsonify(game_state_data)
+
+@app.route('/monsters/data', methods=['GET'])
+def monsters_data_endpoint():
+    return jsonify({
+        "created_monsters": list(created_monsters.values()),
+        "dead_monsters": list(dead_monsters.values())
+    })
+
+# HTML page endpoints
+@app.route('/', methods=['GET'])
+def show_tracker():
+    return render_template('tracker.html')
+
+@app.route('/player', methods=['GET'])
+def show_player():
+    return render_template('player.html')
+
+@app.route('/gamestate', methods=['GET'])
+def show_gamestate():
+    return render_template('gamestate.html')
+
+@app.route('/monsters', methods=['GET'])
+def show_monsters():
+    return render_template('monsters.html')
 
 if __name__ == '__main__':
-    app.run(host='0.0.0.0', port=5000)
\ No newline at end of file
+    app.run(host='0.0.0.0', port=5000, debug=True)
diff --git a/portal/templates/gamestate.html b/portal/templates/gamestate.html
new file mode 100644
index 0000000..b646e1a
--- /dev/null
+++ b/portal/templates/gamestate.html
@@ -0,0 +1,52 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Game State Information</title>
+    <style>
+        .nav-buttons {
+            margin-bottom: 20px;
+        }
+    </style>
+    <script>
+        async function fetchGameStateData() {
+            try {
+                const response = await fetch('/gamestate/data');
+                const data = await response.json();
+                updateGameStateInfo(data);
+            } catch (error) {
+                console.error('Error fetching game state data:', error);
+            }
+        }
+
+        function updateGameStateInfo(gameState) {
+            const gameStateDiv = document.getElementById('game-state-info');
+            gameStateDiv.innerHTML = '';
+
+            for (const [key, value] of Object.entries(gameState)) {
+                const infoItem = document.createElement('p');
+                infoItem.textContent = `${key}: ${value}`;
+                gameStateDiv.appendChild(infoItem);
+            }
+        }
+
+        setInterval(fetchGameStateData, 200);
+        window.onload = fetchGameStateData;
+    </script>
+</head>
+<body>
+    <div class="nav-buttons">
+        <button onclick="window.location.href='/'">Tracker</button>
+        <button onclick="window.location.href='/monsters'">Monsters</button>
+        <button onclick="window.location.href='/player'">Player</button>
+        <button onclick="window.location.href='/gamestate'">Game State</button>
+    </div>
+    
+    <h1>K8s Dungeon Crawl</h1>
+    <h2>Game State Information</h2>
+    <div id="game-state-info">
+        <!-- JavaScript will populate this area with game state data -->
+    </div>
+</body>
+</html>
diff --git a/portal/templates/monsters.html b/portal/templates/monsters.html
new file mode 100644
index 0000000..88e4f55
--- /dev/null
+++ b/portal/templates/monsters.html
@@ -0,0 +1,135 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>K8s Dungeon Crawl - Monster Tracker</title>
+    <style>
+        .dead-monster {
+            background-color: #f8d7da;
+        }
+        table {
+            width: 100%;
+            border-collapse: collapse;
+        }
+        th, td {
+            padding: 8px;
+            text-align: left;
+            border: 1px solid #ddd;
+        }
+        .nav-buttons {
+            margin-bottom: 20px;
+        }
+    </style>
+    <script>
+        async function fetchMonsterData() {
+            try {
+                const response = await fetch('/monsters/data');
+                const data = await response.json();
+                updateTables(data.created_monsters, data.dead_monsters);
+            } catch (error) {
+                console.error('Error fetching monster data:', error);
+            }
+        }
+
+        function updateTables(createdMonsters, deadMonsters) {
+            const createdTableBody = document.getElementById('created-monsters-body');
+            const deadTableBody = document.getElementById('dead-monsters-body');
+
+            createdTableBody.innerHTML = '';
+            deadTableBody.innerHTML = '';
+
+            // Create a set of dead monster IDs for highlighting
+            const deadMonsterIDs = new Set(deadMonsters.map(monster => monster.id));
+
+            // Populate the Created Monsters table
+            createdMonsters.forEach(monster => {
+                const row = document.createElement('tr');
+                if (deadMonsterIDs.has(monster.id)) {
+                    row.classList.add('dead-monster');
+                }
+                row.innerHTML = `
+                    <td>${monster.name || ''}</td>
+                    <td>${monster.hp || ''}</td>
+                    <td>${monster.maxHP || ''}</td>
+                    <td>${monster.level || ''}</td>
+                    <td>${monster.defense || ''}</td>
+                    <td>${monster.accuracy || ''}</td>
+                    <td>${monster.damageMin || ''} - ${monster.damageMax || ''}</td>
+                    <td>${monster.turnsBetweenRegen || ''}</td>
+                    <td>${monster.movementSpeed || ''}</td>
+                    <td>${monster.attackSpeed || ''}</td>
+                    <td>${monster.id || ''}</td>
+                    <td>${monster.type || ''}</td>
+                `;
+                createdTableBody.appendChild(row);
+            });
+
+            // Populate the Dead Monsters table with more details if available
+            deadMonsters.forEach(monster => {
+                const row = document.createElement('tr');
+                row.innerHTML = `
+                    <td>${monster.name || ''}</td>
+                    <td>${monster.level || ''}</td>
+                    <td>${monster.hp || '0'} / ${monster.maxHP || ''}</td>
+                    <td>${monster.id || ''}</td>
+                `;
+                deadTableBody.appendChild(row);
+            });
+        }
+
+        // Fetch and update data every 5 seconds
+        setInterval(fetchMonsterData, 200);
+        window.onload = fetchMonsterData;
+    </script>
+</head>
+<body>
+    <div class="nav-buttons">
+        <button onclick="window.location.href='/'">Tracker</button>
+        <button onclick="window.location.href='/monsters'">Monsters</button>
+        <button onclick="window.location.href='/player'">Player</button>
+        <button onclick="window.location.href='/gamestate'">Game State</button>
+    </div>    
+
+    <h1>K8s Dungeon Crawl</h1>
+    <h2>Monster Tracker</h2>
+
+    <h3>Created Monsters</h3>
+    <table>
+        <thead>
+            <tr>
+                <th>Portal Name</th>
+                <th>Current HP</th>
+                <th>Max HP</th>
+                <th>Depth</th>
+                <th>Defense</th>
+                <th>Accuracy</th>
+                <th>Damage</th>
+                <th>Turns Between Regen</th>
+                <th>Movement Speed</th>
+                <th>Attack Speed</th>
+                <th>ID</th>
+                <th>Type</th>
+            </tr>
+        </thead>
+        <tbody id="created-monsters-body">
+            <!-- JavaScript will populate this area -->
+        </tbody>
+    </table>
+
+    <h3>Dead Monsters</h3>
+    <table>
+        <thead>
+            <tr>
+                <th>Portal Name</th>
+                <th>Depth</th>
+                <th>HP (at death)</th>
+                <th>ID</th>
+            </tr>
+        </thead>
+        <tbody id="dead-monsters-body">
+            <!-- JavaScript will populate this area -->
+        </tbody>
+    </table>
+</body>
+</html>
diff --git a/portal/templates/player.html b/portal/templates/player.html
new file mode 100644
index 0000000..dc75737
--- /dev/null
+++ b/portal/templates/player.html
@@ -0,0 +1,154 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>K8s Dungeon Crawl - Player Information</title>
+    <style>
+        .nav-buttons {
+            margin-bottom: 20px;
+        }
+        .container {
+            display: flex;
+            gap: 20px;
+            margin-top: 20px;
+        }
+        .section {
+            flex: 1;
+            border: 1px solid #ddd;
+            padding: 10px;
+            border-radius: 5px;
+            background-color: #f9f9f9;
+        }
+        .section h2 {
+            text-align: center;
+        }
+        .item-detail {
+            margin-left: 20px;
+        }
+    </style>
+    <script>
+        async function fetchPlayerData() {
+            try {
+                const response = await fetch('/player/data');
+                const data = await response.json();
+                updatePlayerInfo(data);
+            } catch (error) {
+                console.error('Error fetching player data:', error);
+            }
+        }
+
+        function updatePlayerInfo(playerInfo) {
+            const playerStatsDiv = document.getElementById('player-stats');
+            const itemsDiv = document.getElementById('items');
+            const inventoryDiv = document.getElementById('inventory-items');
+            const modifiersDiv = document.getElementById('modifiers');
+
+            playerStatsDiv.innerHTML = '';
+            itemsDiv.innerHTML = '';
+            inventoryDiv.innerHTML = '';
+            modifiersDiv.innerHTML = '';
+
+            const playerStatsKeys = [
+                "currentHP", "gold", "maxHP", "poisonAmount", "regenPerTurn",
+                "stealthRange", "strength", "weaknessAmount"
+            ];
+            const itemKeys = ["weapon", "armor", "ringLeft", "ringRight"];
+            const modifierKeys = [
+                "awarenessBonus", "clairvoyance", "disturbed", "lightMultiplier",
+                "reaping", "regenerationBonus", "stealthBonus", "transference", "wisdomBonus"
+            ];
+
+            // Populate Player Stats section
+            playerStatsKeys.forEach(key => {
+                if (key in playerInfo) {
+                    const statItem = document.createElement('p');
+                    statItem.textContent = `${key}: ${playerInfo[key]}`;
+                    playerStatsDiv.appendChild(statItem);
+                }
+            });
+
+            // Populate Items section with expanded details
+            itemKeys.forEach(key => {
+                if (key in playerInfo && typeof playerInfo[key] === 'object' && playerInfo[key] !== null) {
+                    const itemSection = document.createElement('div');
+                    itemSection.innerHTML = `<strong>${playerInfo[key].name} (${key}):</strong><br>
+                                             <p>${playerInfo[key].description}</p>`;
+
+                    for (const [itemKey, itemValue] of Object.entries(playerInfo[key])) {
+                        if (itemKey !== "name" && itemKey !== "description") {  // Avoid repeating name and description
+                            const itemDetail = document.createElement('p');
+                            itemDetail.className = 'item-detail';
+                            itemDetail.textContent = `${itemKey}: ${itemValue}`;
+                            itemSection.appendChild(itemDetail);
+                        }
+                    }
+                    itemsDiv.appendChild(itemSection);
+                }
+            });
+
+            // Populate Inventory section
+            if (playerInfo.inventory && playerInfo.inventory.length > 0) {
+                playerInfo.inventory.forEach(item => {
+                    const itemDiv = document.createElement('div');
+                    itemDiv.innerHTML = `
+                        <strong>${item.name}</strong> (${item.category}):<br>
+                        Quantity: ${item.quantity}<br>
+                        Armor: ${item.armor || 0}<br>
+                        Damage: ${item.damage ? `${item.damage.min} - ${item.damage.max}` : 'N/A'}<br>
+                        Description: ${item.description}<br><br>
+                    `;
+                    inventoryDiv.appendChild(itemDiv);
+                });
+            } else {
+                inventoryDiv.innerHTML = '<p>No items in inventory.</p>';
+            }
+
+            // Populate Modifiers section
+            modifierKeys.forEach(key => {
+                if (key in playerInfo) {
+                    const modifierItem = document.createElement('p');
+                    modifierItem.textContent = `${key}: ${playerInfo[key]}`;
+                    modifiersDiv.appendChild(modifierItem);
+                }
+            });
+        }
+
+        setInterval(fetchPlayerData, 200);
+        window.onload = fetchPlayerData;
+    </script>
+</head>
+<body>
+    <div class="nav-buttons">
+        <button onclick="window.location.href='/'">Tracker</button>
+        <button onclick="window.location.href='/monsters'">Monsters</button>
+        <button onclick="window.location.href='/player'">Player</button>
+        <button onclick="window.location.href='/gamestate'">Game State</button>
+    </div>
+
+    <h1>K8s Dungeon Crawl</h1>
+    <h2>Player Information</h2>
+
+    <div class="container">
+        <div class="section" id="player-stats-section">
+            <h2>Player Stats</h2>
+            <div id="player-stats"></div>
+        </div>
+
+        <div class="section" id="items-section">
+            <h2>Equipped Items</h2>
+            <div id="items"></div>
+        </div>
+
+        <div class="section" id="inventory-section">
+            <h2>Inventory</h2>
+            <div id="inventory-items"></div>
+        </div>
+
+        <div class="section" id="modifiers-section">
+            <h2>Modifiers</h2>
+            <div id="modifiers"></div>
+        </div>
+    </div>
+</body>
+</html>
diff --git a/portal/templates/tracker.html b/portal/templates/tracker.html
new file mode 100644
index 0000000..69a39fa
--- /dev/null
+++ b/portal/templates/tracker.html
@@ -0,0 +1,36 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Tracker Landing Page</title>
+    <style>
+        .nav-buttons {
+            margin-top: 50px;
+            display: flex;
+            flex-direction: column;
+            align-items: center;
+        }
+        button {
+            padding: 10px 20px;
+            margin: 10px;
+            font-size: 16px;
+            cursor: pointer;
+        }
+        h1 {
+            text-align: center;
+            margin-top: 50px;
+            font-size: 2em;
+        }
+    </style>
+</head>
+<body>
+    <h1>Welcome to the Tracker</h1>
+
+    <div class="nav-buttons">
+        <button onclick="window.location.href='/monsters'">Monsters</button>
+        <button onclick="window.location.href='/player'">Player</button>
+        <button onclick="window.location.href='/gamestate'">Game State</button>
+    </div>
+</body>
+</html>
